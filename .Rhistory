w_spec <- boost_tree(learn_rate = tune(),
tree_depth = tune(),
min_n = tune()) %>%
set_engine("xgboost") %>%
set_mode("classification")
mlp_brulee_spec <-
mlp(
hidden_units = c(10,10),
dropout      = tune(),
epochs       = tune(),
learn_rate   = tune(),
activation   = "elu"
) %>%
set_engine("brulee") %>%
set_mode("classification")
# 2.3. Model tuning
w_grid <- grid_random(tree_depth(),
learn_rate(),
min_n(),
size = 10)
mlp_brulee_params <-
mlp_brulee_spec %>%
extract_parameter_set_dials() %>%
update(
epochs  = epochs(c(10, 200)),
dropout = dropout(c(0.1, 0.9))
)
mlp_brulee_start <-
mlp_brulee_params %>%
grid_regular(levels = 3)
w_grid
# 3. Workflow specification
registerDoParallel(cores=7)
set.seed(339)
environment_wf <- workflow() %>%
add_recipe(w.recipe) %>%
add_model(w_spec)
environment_res <-
environment_wf %>% tune_race_anova(
resamples = df.masterfile.pred.split.train.folds,
grid = w_grid,
control = control_race(save_pred = T),
metrics = metric_set(roc_auc, accuracy)
)
environment_wf <- workflow() %>%
add_recipe(w.recipe) %>%
add_model(w_spec)
environment_res <-
environment_wf %>% tune_race_anova(
resamples = df.masterfile.pred.split.train.folds,
grid = w_grid,
control = control_race(save_pred = T),
metrics = metric_set(roc_auc, accuracy)
)
# 2. Build the model
# 2.1 Define recipe
w.recipe <- df.masterfile.pred.split.train %>%
#train_explore %>%
recipe(environment_coded ~ .) %>%
update_role(id, new_role = "id") %>%
#step_interact(terms = ~ bluetooth:feldstärke_mean) %>%
#step_interact(terms = ~ bluetooth:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:snr) %>%
#step_interact(terms = ~ bluetooth:ddvi) %>%
#step_interact(terms = ~ ddvi:snr) %>%
step_indicate_na(all_predictors()) %>%
step_impute_median(all_numeric_predictors()) %>%
#step_interact(terms = ~ bluetooth:hour_of_day) %>%
#step_dummy(all_nominal_predictors()) %>%
step_YeoJohnson(all_numeric_predictors()) %>%
step_normalize(all_numeric(),-has_role(match = "id")) %>%
step_nzv(all_predictors()) #%>%
w.recipe.prep <- w.recipe %>% prep()
juice(w.recipe.prep)  %>% select(-id) %>% GGally::ggpairs()
table(juice(w.recipe.prep)$environment_coded )
# 2.2. Model specification
w_spec <- boost_tree(learn_rate = tune(),
tree_depth = tune(),
min_n = tune()) %>%
set_engine("xgboost") %>%
set_mode("classification")
mlp_brulee_spec <-
mlp(
hidden_units = c(10,10),
dropout      = tune(),
epochs       = tune(),
learn_rate   = tune(),
activation   = "elu"
) %>%
set_engine("brulee") %>%
set_mode("classification")
# 2.3. Model tuning
w_grid <- grid_random(tree_depth(),
learn_rate(),
min_n(),
size = 10)
mlp_brulee_params <-
mlp_brulee_spec %>%
extract_parameter_set_dials() %>%
update(
epochs  = epochs(c(10, 200)),
dropout = dropout(c(0.1, 0.9))
)
mlp_brulee_start <-
mlp_brulee_params %>%
grid_regular(levels = 3)
w_grid
# 3. Workflow specification
registerDoParallel(cores=7)
set.seed(339)
environment_wf <- workflow() %>%
add_recipe(w.recipe) %>%
add_model(w_spec)
environment_res <-
environment_wf %>% tune_race_anova(
resamples = df.masterfile.pred.split.train.folds,
grid = w_grid,
control = control_race(save_pred = T),
metrics = metric_set(roc_auc, accuracy)
)
doParallel::stopImplicitCluster()
doParallel::stopImplicitCluster()
# 3. Workflow specification
registerDoParallel(cores=4)
show_notes(.Last.tune.result)
# 2. Build the model
# 2.1 Define recipe
w.recipe <- df.masterfile.pred.split.train %>%
#train_explore %>%
recipe(environment_coded ~ .) %>%
update_role(id, new_role = "id") %>%
#step_interact(terms = ~ bluetooth:feldstärke_mean) %>%
#step_interact(terms = ~ bluetooth:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:snr) %>%
#step_interact(terms = ~ bluetooth:ddvi) %>%
#step_interact(terms = ~ ddvi:snr) %>%
step_indicate_na(all_predictors()) %>%
step_impute_median(all_numeric_predictors()) %>%
#step_interact(terms = ~ bluetooth:hour_of_day) %>%
#step_dummy(all_nominal_predictors()) %>%
step_YeoJohnson(all_numeric_predictors()) %>%
step_nzv(all_predictors()) %>%
step_normalize(all_numeric(),-has_role(match = "id")) #%>%
w.recipe.prep <- w.recipe %>% prep()
juice(w.recipe.prep)  %>% select(-id) %>% GGally::ggpairs()
table(juice(w.recipe.prep)$environment_coded )
# 2.2. Model specification
w_spec <- boost_tree(learn_rate = tune(),
tree_depth = tune(),
min_n = tune()) %>%
set_engine("xgboost") %>%
set_mode("classification")
mlp_brulee_spec <-
mlp(
hidden_units = c(10,10),
dropout      = tune(),
epochs       = tune(),
learn_rate   = tune(),
activation   = "elu"
) %>%
set_engine("brulee") %>%
set_mode("classification")
# 2.3. Model tuning
w_grid <- grid_random(tree_depth(),
learn_rate(),
min_n(),
size = 10)
mlp_brulee_params <-
mlp_brulee_spec %>%
extract_parameter_set_dials() %>%
update(
epochs  = epochs(c(10, 200)),
dropout = dropout(c(0.1, 0.9))
)
mlp_brulee_start <-
mlp_brulee_params %>%
grid_regular(levels = 3)
w_grid
# 3. Workflow specification
registerDoParallel(cores=4)
set.seed(339)
environment_wf <- workflow() %>%
add_recipe(w.recipe) %>%
add_model(w_spec)
environment_res <-
environment_wf %>% tune_race_anova(
resamples = df.masterfile.pred.split.train.folds,
grid = w_grid,
control = control_race(save_pred = T),
metrics = metric_set(roc_auc, accuracy)
)
# 2. Build the model
# 2.1 Define recipe
w.recipe <- df.masterfile.pred.split.train %>%
#train_explore %>%
recipe(environment_coded ~ .) %>%
update_role(id, new_role = "id") %>%
#step_interact(terms = ~ bluetooth:feldstärke_mean) %>%
#step_interact(terms = ~ bluetooth:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:snr) %>%
#step_interact(terms = ~ bluetooth:ddvi) %>%
#step_interact(terms = ~ ddvi:snr) %>%
step_indicate_na(all_predictors(),-has_name("snr")) %>%
step_impute_median(all_numeric_predictors()) %>%
#step_interact(terms = ~ bluetooth:hour_of_day) %>%
#step_dummy(all_nominal_predictors()) %>%
step_YeoJohnson(all_numeric_predictors()) %>%
step_nzv(all_predictors()) %>%
step_normalize(all_numeric(),-has_role(match = "id")) #%>%
w.recipe.prep <- w.recipe %>% prep()
# 2. Build the model
# 2.1 Define recipe
w.recipe <- df.masterfile.pred.split.train %>%
#train_explore %>%
recipe(environment_coded ~ .) %>%
update_role(id, new_role = "id") %>%
#step_interact(terms = ~ bluetooth:feldstärke_mean) %>%
#step_interact(terms = ~ bluetooth:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:snr) %>%
#step_interact(terms = ~ bluetooth:ddvi) %>%
#step_interact(terms = ~ ddvi:snr) %>%
step_indicate_na(all_predictors(),-has_name(name = "snr")) %>%
step_impute_median(all_numeric_predictors()) %>%
#step_interact(terms = ~ bluetooth:hour_of_day) %>%
#step_dummy(all_nominal_predictors()) %>%
step_YeoJohnson(all_numeric_predictors()) %>%
step_nzv(all_predictors()) %>%
step_normalize(all_numeric(),-has_role(match = "id")) #%>%
w.recipe.prep <- w.recipe %>% prep()
# 2. Build the model
# 2.1 Define recipe
w.recipe <- df.masterfile.pred.split.train %>%
#train_explore %>%
recipe(environment_coded ~ .) %>%
update_role(id, new_role = "id") %>%
#step_interact(terms = ~ bluetooth:feldstärke_mean) %>%
#step_interact(terms = ~ bluetooth:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:snr) %>%
#step_interact(terms = ~ bluetooth:ddvi) %>%
#step_interact(terms = ~ ddvi:snr) %>%
step_indicate_na(columns = "ddvi") %>%
step_impute_median(all_numeric_predictors()) %>%
#step_interact(terms = ~ bluetooth:hour_of_day) %>%
#step_dummy(all_nominal_predictors()) %>%
step_YeoJohnson(all_numeric_predictors()) %>%
step_nzv(all_predictors()) %>%
step_normalize(all_numeric(),-has_role(match = "id")) #%>%
w.recipe.prep <- w.recipe %>% prep()
juice(w.recipe.prep)  %>% select(-id) %>% GGally::ggpairs()
juice(w.recipe.prep)
# 2. Build the model
# 2.1 Define recipe
w.recipe <- df.masterfile.pred.split.train %>%
#train_explore %>%
recipe(environment_coded ~ .) %>%
update_role(id, new_role = "id") %>%
#step_interact(terms = ~ bluetooth:feldstärke_mean) %>%
#step_interact(terms = ~ bluetooth:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:snr) %>%
#step_interact(terms = ~ bluetooth:ddvi) %>%
#step_interact(terms = ~ ddvi:snr) %>%
step_indicate_na("snr") %>%
step_impute_median(all_numeric_predictors()) %>%
#step_interact(terms = ~ bluetooth:hour_of_day) %>%
#step_dummy(all_nominal_predictors()) %>%
step_YeoJohnson(all_numeric_predictors()) %>%
step_nzv(all_predictors()) %>%
step_normalize(all_numeric(),-has_role(match = "id")) #%>%
w.recipe.prep <- w.recipe %>% prep()
juice(w.recipe.prep)  %>% select(-id) %>% GGally::ggpairs()
table(juice(w.recipe.prep)$environment_coded )
# 2.2. Model specification
w_spec <- boost_tree(learn_rate = tune(),
tree_depth = tune(),
min_n = tune()) %>%
set_engine("xgboost") %>%
set_mode("classification")
mlp_brulee_spec <-
mlp(
hidden_units = c(10,10),
dropout      = tune(),
epochs       = tune(),
learn_rate   = tune(),
activation   = "elu"
) %>%
set_engine("brulee") %>%
set_mode("classification")
# 2.3. Model tuning
w_grid <- grid_random(tree_depth(),
learn_rate(),
min_n(),
size = 10)
mlp_brulee_params <-
mlp_brulee_spec %>%
extract_parameter_set_dials() %>%
update(
epochs  = epochs(c(10, 200)),
dropout = dropout(c(0.1, 0.9))
)
mlp_brulee_start <-
mlp_brulee_params %>%
grid_regular(levels = 3)
w_grid
# 3. Workflow specification
registerDoParallel(cores=4)
set.seed(339)
environment_wf <- workflow() %>%
add_recipe(w.recipe) %>%
add_model(w_spec)
environment_res <-
environment_wf %>% tune_race_anova(
resamples = df.masterfile.pred.split.train.folds,
grid = w_grid,
control = control_race(save_pred = T),
metrics = metric_set(roc_auc, accuracy)
)
show_notes(.Last.tune.result)
juice(w.recipe.prep)
juice(w.recipe.prep)  %>% filter( if_any(everything(), is.na))
juice(w.recipe.prep)  %>% View()
df.masterfile.pred
df.masterfile.pred %>% filter(is.na(environment_coded))
df.masterfile.pred <- df.bluetooth.summarized %>%
inner_join(df.masterfile.nona %>%
select(-c(contains("feldstärke"))), by = "entryId") %>%
select(bluetooth,feldstärke_median,snr, j,feldstärke_range,feldstärke_sd,feldstärke_cv,environment_coded, response_Time,response_Date) %>%
mutate(hour_of_day = lubridate::hour(response_Time), day_of_week = weekdays(response_Date),
weekend = as.factor(ifelse(day_of_week %in% c("Samstag", "Sonntag"), 1, 0)) )%>%
#na.omit %>%
select(-day_of_week,-response_Date) %>%
#mutate(environment_coded = fct_collapse(environment_coded, Urban = c("Parks", "Staedtisch"), Rural = c("Wald,Wiese","Wasser","Berge","Laendlich", "Vorstaedtisch") )) %>%
mutate(id = row_number()) %>%
mutate(bluetooth = log(bluetooth + 1), ddvi = bluetooth /  (feldstärke_sd +10 )) %>%
# select final set of columns
select(id,
environment_coded,
bluetooth,
ddvi,
snr,
#feldstärke_median,
#feldstärke_sd,
#feldstärke_range,
j,
#feldstärke_cv,
#weekend,
#hour_of_day
) %>%
filter(!(environment_coded %in% c("Berge","Wald,Wiese","Wasser","Parks")) & !is.na(environment_coded))
df.masterfile.pred %>% filter(is.na(environment_coded))
df.masterfile.pred
df.masterfile.pred <- df.bluetooth.summarized %>%
inner_join(df.masterfile.nona %>%
select(-c(contains("feldstärke"))), by = "entryId") %>%
select(bluetooth,feldstärke_median,snr, j,feldstärke_range,feldstärke_sd,feldstärke_cv,environment_coded, response_Time,response_Date) %>%
mutate(hour_of_day = lubridate::hour(response_Time), day_of_week = weekdays(response_Date),
weekend = as.factor(ifelse(day_of_week %in% c("Samstag", "Sonntag"), 1, 0)) )%>%
#na.omit %>%
select(-day_of_week,-response_Date) %>%
#mutate(environment_coded = fct_collapse(environment_coded, Urban = c("Parks", "Staedtisch"), Rural = c("Wald,Wiese","Wasser","Berge","Laendlich", "Vorstaedtisch") )) %>%
mutate(id = row_number()) %>%
mutate(bluetooth = log(bluetooth + 1), ddvi = bluetooth /  (feldstärke_sd +10 )) %>%
# select final set of columns
select(id,
environment_coded,
bluetooth,
ddvi,
snr,
#feldstärke_median,
#feldstärke_sd,
#feldstärke_range,
j,
#feldstärke_cv,
#weekend,
#hour_of_day
) %>%
filter(!(environment_coded %in% c("Berge","Wald,Wiese","Wasser","Parks")) & !is.na(environment_coded))
df.masterfile.pred$environment_coded <- factor(df.masterfile.pred$environment_coded )
table(df.masterfile.pred$environment_coded )
df.masterfile.pred %>%
group_by(environment_coded) %>%
summarize(bt = mean(bluetooth),
feldstärke_mean = mean(feldstärke_mean,na.rm = T),
#entropy = mean(entropy,na.rm=T),
#gini = 100*mean(gini,na.rm=T),
feldstärke_sd = mean(feldstärke_sd,na.rm=T),
feldstärke_range = mean(feldstärke_range,na.rm=T),
snr = mean(snr,na.rm=T),
#feldstärke_cv = mean(feldstärke_cv,na.rm=T),
t = mean(hour_of_day)) %>%
filter(!is.na(environment_coded)) %>%
pivot_longer(cols=c(bt,feldstärke_mean,feldstärke_sd,feldstärke_range,t,snr)) %>%
ggplot() +
geom_col(aes(x=environment_coded, y = value, fill=environment_coded),position=position_dodge())+
theme_ipsum()+ scale_fill_viridis_d()+
theme(axis.text.x = element_text(angle=30,hjust=1))+
facet_wrap(~name)
# 1. define bootstrap / resamples for cross-validation
#df.masterfile.pred.boot <- bootstraps(df.masterfile.pred,
#                                      times = 25)
df.masterfile.pred.split <- initial_split(df.masterfile.pred, strata = "environment_coded")
df.masterfile.pred.split.train <- training(df.masterfile.pred.split)
df.masterfile.pred.split.test  <- testing(df.masterfile.pred.split)
df.masterfile.pred.split.train.folds <- vfold_cv(df.masterfile.pred.split.train, v = 5, strata = environment_coded)
# 2. Build the model
# 2.1 Define recipe
w.recipe <- df.masterfile.pred.split.train %>%
#train_explore %>%
recipe(environment_coded ~ .) %>%
update_role(id, new_role = "id") %>%
#step_interact(terms = ~ bluetooth:feldstärke_mean) %>%
#step_interact(terms = ~ bluetooth:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_range) %>%
#step_interact(terms = ~ feldstärke_mean:feldstärke_sd) %>%
#step_interact(terms = ~ bluetooth:snr) %>%
#step_interact(terms = ~ bluetooth:ddvi) %>%
#step_interact(terms = ~ ddvi:snr) %>%
step_indicate_na("snr") %>%
step_impute_median(all_numeric_predictors()) %>%
#step_interact(terms = ~ bluetooth:hour_of_day) %>%
#step_dummy(all_nominal_predictors()) %>%
step_YeoJohnson(all_numeric_predictors()) %>%
step_nzv(all_predictors()) %>%
step_normalize(all_numeric(),-has_role(match = "id")) #%>%
w.recipe.prep <- w.recipe %>% prep()
juice(w.recipe.prep)  %>% filter( if_any(everything(), is.na))
juice(w.recipe.prep)  #%>% select(-id) %>% GGally::ggpairs()
table(juice(w.recipe.prep)$environment_coded )
# 2.2. Model specification
w_spec <- boost_tree(learn_rate = tune(),
tree_depth = tune(),
min_n = tune()) %>%
set_engine("xgboost") %>%
set_mode("classification")
mlp_brulee_spec <-
mlp(
hidden_units = c(10,10),
dropout      = tune(),
epochs       = tune(),
learn_rate   = tune(),
activation   = "elu"
) %>%
set_engine("brulee") %>%
set_mode("classification")
# 2.3. Model tuning
w_grid <- grid_random(tree_depth(),
learn_rate(),
min_n(),
size = 10)
mlp_brulee_params <-
mlp_brulee_spec %>%
extract_parameter_set_dials() %>%
update(
epochs  = epochs(c(10, 200)),
dropout = dropout(c(0.1, 0.9))
)
mlp_brulee_start <-
mlp_brulee_params %>%
grid_regular(levels = 3)
w_grid
# 3. Workflow specification
registerDoParallel(cores=4)
set.seed(339)
environment_wf <- workflow() %>%
add_recipe(w.recipe) %>%
add_model(w_spec)
environment_res <-
environment_wf %>% tune_race_anova(
resamples = df.masterfile.pred.split.train.folds,
grid = w_grid,
control = control_race(save_pred = T),
metrics = metric_set(roc_auc, accuracy)
)
doParallel::stopImplicitCluster()
autoplot(environment_res)
environment_res %>% collect_metrics(summarize = TRUE)
# extract the best model from the workflow
environment_res %>% show_best(metric= "roc_auc")
best_xgfboost <- finalize_workflow(environment_wf,select_best(environment_res,metric =  "roc_auc")) %>%
last_fit(split=df.masterfile.pred.split)
# collect the metrics for the best model
best_xgfboost |>
collect_metrics()
best_xgfboost |>
collect_predictions() |>
roc_curve(truth=environment_coded, c(.pred_Laendlich,.pred_Staedtisch,.pred_Vorstaedtisch) )|>
autoplot()
# 6. variable importance
library(vip)
best_xgfboost %>%
extract_fit_parsnip() %>%
vip(geom = "col") + theme_ipsum()
juice(w.recipe.prep)
juice(w.recipe.prep)  %>% select(-id) %>% GGally::ggpairs()
